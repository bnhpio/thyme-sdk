---
title: CLI + SDK Workflow
description: Combine the Thyme SDK and CLI for an end-to-end automation pipeline.
---

# CLI + SDK Workflow

Use the SDK for authoring and testing logic, and the CLI for project orchestration. This guide shows how to compose both layers into a reliable delivery pipeline with Bun.

## Prerequisites

- Node.js 18+
- Bun (latest stable)
- Access to Ethereum RPC endpoints (Infura, Alchemy, self-hosted)
- Auth token for uploads

## 1. Bootstrap the Workspace

```bash
thyme create treasury-automation
cd treasury-automation
bun install
cp .env.example .env
```

Populate `.env` with RPC URLs, deploy endpoint, and placeholder secrets. Never paste private keys directly into code—reference them via env variables only.

## 2. Model Function Inputs

`functions/stream-payout/schema.ts`:

```ts
import { z } from 'zod'

export const schema = z.object({
  recipient: z.string().regex(/^0x[a-fA-F0-9]{40}$/),
  amountWei: z.string().transform((value) => BigInt(value)),
  memo: z.string().max(64).optional(),
})

export interface Args extends z.infer<typeof schema> {}
```

Commit schemas early so the CLI can validate `args.json` before sandbox execution.

## 3. Build the Runner with the SDK

`functions/stream-payout/index.ts`:

```ts
import { onFail, onRun, onSuccess } from '@bnhpio/thyme-sdk/runner'
import { parseEther } from 'viem'
import type { Args } from './schema'

function createRunner() {
  const run = onRun<Args>(async (ctx) => {
    const { recipient, amountWei } = ctx.userArgs
    if (!recipient) return { canExec: false, message: 'Missing recipient' }

    return {
      canExec: true,
      calls: [
        {
          to: recipient,
          data: '0x',
          value: amountWei,
        },
      ],
    }
  })

  const success = onSuccess<Args>(async (ctx) => {
    console.log(`stream executed for ${ctx.userArgs.recipient}`)
  })

  const fail = onFail<Args>(async (ctx, result, error) => {
    console.error('stream failed', error?.message)
  })

  return { run, success, fail }
}

export default createRunner()
```

Use helper factories (`createRunner`) to keep runners composable and testable outside the CLI.

## 4. Local Simulation Loop

### Programmatic (SDK)

```ts
import { simulateTask } from '@bnhpio/thyme-sdk/runner'
import runner from './functions/stream-payout'

async function smokeTest() {
  const rpcUrl = process.env.SEPOLIA_RPC_URL
  if (!rpcUrl) throw new Error('Missing RPC URL')

  await simulateTask({
    runner,
    options: { rpcUrl, account: process.env.TEST_ACCOUNT_ADDRESS },
    context: {
      userArgs: {
        recipient: '0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb',
        amountWei: parseEther('0.1'),
      },
      secrets: {},
    },
  })
}
```

### CLI (Sandbox + Onchain)

```bash
thyme simulate stream-payout --profile sepolia-test
```

The CLI route ensures the same artifacts used for deployment are validated—no drift between local tests and production builds.

## 5. Package and Upload

```bash
thyme auth <token>             # one time
thyme upload stream-payout \
  --organizationId treasury \
  --env .env
```

Under the hood the CLI:

1. Leverages the SDK archive utilities to compress files
2. Uses sandbox + onchain modules for a final verification pass
3. Sends the archive plus metadata to `DEPLOY_URL`

## 6. Automate CI

Run the same steps in CI to prevent regressions:

```bash
bun test
thyme simulate stream-payout --profile sepolia-test --env .env.ci
```

Block merges unless simulations pass. Add `thyme upload` to release pipelines only, guarded by multisig-seeded tokens.

## Tips for Team Workflows

- **RORO everywhere**: keep CLI configs and SDK factories aligned by using object params exclusively
- **Single source of truth**: store network data in `untl.toml` and reuse via both SDK scripts and CLI invocations
- **Secrets hygiene**: pass API keys through `.env` + `thyme auth`; never commit tokens or private keys
- **Artifact parity**: rely on CLI simulations for sign-off, but keep SDK-level unit tests for faster feedback
- **Version pinning**: lock SDK and CLI versions together inside `package.json` to avoid breaking changes mid-release

Following this loop gives you IDE-friendly authoring via the SDK, battle-tested packaging through the CLI, and reproducible deployments.

